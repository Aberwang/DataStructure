# -*- coding: utf-8 -*-
# Author: wangliang
# Create Time: 2022/4/25 16:41


"""
冒泡排序
原理：
    冒泡排序的核心思想是：通过双层循环遍历，每次比较两个数，如果他们顺序错误（大于或者小于），那么就把他们位置交换。

步骤：
• 首先，比较第一个数和第二个数的大小，由于是从小到大排列，所以如果第一个数大于第二个数，则将这两个数互换位置，反之则不变。
• 然后进行第二个数和第三个数比较，同上。
• 这样依次比较一轮后，你会发现，总共比了4次，也就是说，如果有n个数进行比较，那么需要n-1次才能完成。
• 上面过程主要完成了一轮比较，最终确定了一个最大的数，并且排在5个数的最后，也就是第五个数。
• 那么也就意味着需要在进行第一个数到第四个数的一轮比较，确定最大值。
• 接着从第一个数到第三个数......
• 这样规律就很明显了，五个数需要比较四轮，就能将5个数升序排列，所以n个数需要比较n-1轮。

算法特点：
    时间复杂度：O(n^2)
    空间复杂度：O(1)
    时间复杂度：「最好：O(n)」「最坏：O(n^2)」「平均：O(n^2)」
    原地排序
    稳定性：稳定排序
"""


def maopao_sort(ls):
    n = len(ls)
    if n <= 1:
        return ls

    for i in range(n-1):
        for j in range(n-i-1):
            if ls[j] > ls[j+1]:
                ls[j], ls[j+1] = ls[j+1], ls[j]

    return ls


# 算法改进：
# （改进之后的最优时间复杂度：O(n)，表示遍历一次发现没有任何可以交换的元素，原序列有序，排序结束）
def maopao_sort2(ls):
    n = len(ls)
    if n <= 1:
        return ls

    for i in range(n):
        count = 0
        for j in range(n-i-1):
            if ls[j] > ls[j+1]:
                ls[j], ls[j + 1] = ls[j + 1], ls[j]
                count += 1

        # 当遍历一次后，发现没有元素交换，就意味着原序列有序，直接退出
        if count == 0:
            return ls
    return ls

if __name__ == "__main__":
    ls = [17, 54, 26, 93, 37, 77, 31, 44, 55, 20]
    print(ls)
    maopao_sort(ls)
    print(ls)
